package org.powerbot.game.api.methods.widget;

import java.util.LinkedList;
import java.util.List;

import org.powerbot.game.api.methods.Widgets;
import org.powerbot.game.api.util.Filter;
import org.powerbot.game.api.wrappers.widget.ChatOption;
import org.powerbot.game.api.wrappers.widget.Widget;
import org.powerbot.game.api.wrappers.widget.WidgetChild;

/**
 * @author Stephan J. Bijzitter (Salvation)
 * @since 26-04-2012
 */
public class ChatOptions {
	private static final int WIDGET_CHAT = 1188;

	/**
	 * A total of five (5) options can be seen on one parent.
	 * The following numbers are their indices of their option- and number-components respectively:
	 * #1: 03, 12
	 * #2: 24, 25
	 * #3: 29, 30
	 * #4: 34, 35
	 * #5: 39, 40
	 * The number-components are always valid and never visible.
	 * The number-components' getText() returns always the same.
	 * The option-components are always valid and never visible.
	 * The option-components' getText() is empty or null if the option is non-existent.
	 */
	private static final int[][] OPTION_ARRAY = {
			{3, 12},
			{24, 25},
			{29, 30},
			{34, 35},
			{39, 40}
	};

	/**
	 * @return The parent Widget possibly containing ChatOptions.
	 */
	public static Widget getWidget() {
		return Widgets.get(WIDGET_CHAT);
	}

	/**
	 * @return A list containing all active ChatOptions.
	 */
	public static List<ChatOption> getOptions() {
		final Widget w = getWidget();
		final List<ChatOption> list = new LinkedList<ChatOption>();

		if (w != null) {
			for (int i = 1; i < 6; i++) {
				final int[] array = OPTION_ARRAY[i - 1];
				final WidgetChild a = w.getChild(array[0]);
				final WidgetChild b = w.getChild(array[1]);

				if (a != null && b != null && a.validate() && b.validate()) {
					final String s = b.getText();

					if (s != null && s.startsWith(Integer.toString(i))) {
						list.add(new ChatOption(i, a));
						continue;
					}
				}
				break;
			}
		}
		return list;
	}

	/**
	 * @param option A ChatOption's getText() must partially contains this String to be added to the list.
	 * @return A list of ChatOptions containing specified option.
	 */
	public static List<ChatOption> getOptions(final String option) {
		final List<ChatOption> list = new LinkedList<ChatOption>();
		for (final ChatOption w : getOptions()) {
			if (w.getWidgetChild().getText().toLowerCase().contains(option.toLowerCase())) {
				list.add(w);
			}
		}
		return list;
	}

	/**
	 * @param filter A Filter which must accept a ChatOption for it to be added to the list.
	 * @return A list of ChatOptions accepted by the filter.
	 */
	public static List<ChatOption> getOptions(final Filter<ChatOption> filter) {
		final List<ChatOption> list = new LinkedList<ChatOption>();
		for (final ChatOption w : getOptions()) {
			if (filter.accept(w)) {
				list.add(w);
			}
		}
		return list;
	}

	/**
	 * @param option The option String to be used by getOptions(String option).
	 * @return The first instance in the list generated by getOptions(String option) if existent, otherwise null.
	 */
	public static ChatOption getOption(final String option) {
		final List<ChatOption> list = getOptions(option);
		return list.isEmpty() ? null : list.get(0);
	}

	/**
	 * @return The first instance in the list generated by getOptions(Filter<ChatOption> filter) if existent, otherwise null.
	 */
	public static ChatOption getOption(final Filter<ChatOption> filter) {
		final List<ChatOption> list = getOptions(filter);
		return list.isEmpty() ? null : list.get(0);
	}

	/**
	 * @return Widgets.canContinue().
	 */
	public static boolean canContinue() {
		return Widgets.canContinue();
	}

	/**
	 * @return A new instance of the continue option.
	 */
	public static ChatOption getContinueOption() {
		return new ChatOption(-1, Widgets.getContinue());
	}
}